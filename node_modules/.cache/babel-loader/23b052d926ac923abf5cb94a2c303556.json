{"ast":null,"code":"//     wink-lemmatizer\n//     English lemmatizer\n//\n//     This file is part of “wink-lemmatizer”.\n//\n//     Copyright (c) GRAYPE Systems Private Limited\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n// Load adjective/noun/verb exceptions.\nvar adjectiveExceptions = require('wink-lexicon/src/wn-adjective-exceptions.js');\n\nvar nounExceptions = require('wink-lexicon/src/wn-noun-exceptions.js');\n\nvar verbExceptions = require('wink-lexicon/src/wn-verb-exceptions.js'); // Load all words (base form),\n\n\nvar words = require('wink-lexicon/src/wn-words.js'); // and their senses.\n\n\nvar senseMap = require('wink-lexicon/src/wn-word-senses.js'); // The name space.\n\n\nvar lemmatize = Object.create(null); // The following code is an adaptation of [WordNet's Morphy](https://wordnet.princeton.edu/documentation/morphy7wn):\n// ### isAdjective\n\n/**\n * Checks the word in base form is an adjective or not using wordnet senses.\n *\n * @private\n * @method isAdjective\n * @param {string} word that needs to be tested for adjective.\n * @return {boolean} `true` if word is a valid adjective otherwise `false.`\n * @example\n * isAdjective( 'lat' );\n * // -> false\n*/\n\nvar isAdjective = function isAdjective(word) {\n  var index = words[word];\n  if (index === undefined) return false;\n  var senses = senseMap[index];\n\n  for (var k = 0; k < senses.length; k += 1) {\n    if (senses[k] < 2) return true;\n  }\n\n  return false;\n}; // isAdjective()\n// ### lemmatizeAdjective\n\n/**\n *\n * Conjugates an `adjective` to it's base form (VB). It also has an alias\n * `lemmatizeAdjective` to maintain API level compatibility with previous version.\n *\n * @method adjective\n * @param {string} adjective that needs to be conjugated to base form.\n * @return {string} the base form of `adjective`.\n * @example\n * lemmatize.adjective( 'farthest' );\n * // -> far\n*/\n\n\nlemmatize.adjective = function (adjective) {\n  var lemma = adjectiveExceptions[adjective];\n  if (lemma) return lemma;\n  lemma = adjective.replace(/est$|er$/, '');\n  if (lemma.length === adjective.length) return adjective;\n  if (isAdjective(lemma)) return lemma;\n  lemma += 'e';\n  if (isAdjective(lemma)) return lemma;\n  return adjective;\n}; // adjective()\n// ### isVerb\n\n/**\n * Checks the word in base form is a verb or not using wordnet senses.\n *\n * @private\n * @method isVerb\n * @param {string} word that needs to be tested for verb.\n * @return {boolean} `true` if word is a valid verb otherwise `false.`\n * @example\n * isVerb( 'eat' );\n * // -> true\n*/\n\n\nvar isVerb = function isVerb(word) {\n  var index = words[word];\n  if (index === undefined) return false;\n  var senses = senseMap[index];\n\n  for (var k = 0; k < senses.length; k += 1) {\n    if (senses[k] > 28 && senses[k] < 44) return true;\n  }\n\n  return false;\n}; // isVerb()\n// ### lemmatizeVerb\n\n/**\n *\n * Conjugates a `verb` to it's base form (VB). It also has an alias\n * `lemmatizeVerb` to maintain API level compatibility with previous version.\n *\n * @method verb\n * @param {string} verb that needs to be conjugated to base form.\n * @return {string} the base form of `verb`.\n * @example\n * lemmatize.verb( 'winning' );\n * // -> win\n*/\n\n\nlemmatize.verb = function (verb) {\n  var lemma = verbExceptions[verb];\n  if (lemma) return lemma;\n  lemma = verb.replace(/s$/, '');\n  if (lemma.length !== verb.length && isVerb(lemma)) return lemma;\n  lemma = verb.replace(/ies$/, 'y');\n  if (lemma.length !== verb.length && isVerb(lemma)) return lemma;\n  lemma = verb.replace(/es$|ed$|ing$/, '');\n\n  if (lemma.length !== verb.length) {\n    if (isVerb(lemma)) return lemma;\n    lemma += 'e';\n    if (isVerb(lemma)) return lemma;\n  }\n\n  return verb;\n}; // verb()\n\n\nvar nounRegexes = [{\n  replace: /s$/,\n  by: ''\n}, {\n  replace: /ses$/,\n  by: 's'\n}, {\n  replace: /xes$/,\n  by: 'x'\n}, {\n  replace: /zes$/,\n  by: 's'\n}, {\n  replace: /ves$/,\n  by: 'f'\n}, {\n  replace: /ches$/,\n  by: 'ch'\n}, {\n  replace: /shes$/,\n  by: 'sh'\n}, {\n  replace: /men$/,\n  by: 'man'\n}, {\n  replace: /ies$/,\n  by: 'y'\n}]; // ### isNoun\n\n/**\n * Checks the word in base form is a noun or not using wordnet senses.\n *\n * @private\n * @method isNoun\n * @param {string} word that needs to be tested for noun.\n * @return {boolean} `true` if word is a valid noun otherwise `false.`\n * @example\n * isAdjective( 'house' );\n * // -> true\n*/\n\nvar isNoun = function isNoun(word) {\n  var index = words[word];\n  if (index === undefined) return false;\n  var senses = senseMap[index];\n\n  for (var k = 0; k < senses.length; k += 1) {\n    if (senses[k] > 2 && senses[k] < 29) return true;\n  }\n\n  return false;\n}; // isNoun()\n// ### lemmatizeNoun\n\n/**\n *\n * Converts the input `noun` to it's singular form. It also has an alias\n * `lemmatizeNoun` to maintain API level compatibility with previous version.\n *\n * @method noun\n * @param {string} noun that needs to be lemmatized.\n * @return {string} the singular of `noun`.\n * @example\n * lemmatize.noun( 'handkerchieves' );\n * // -> handkerchief\n*/\n\n\nlemmatize.noun = function (noun) {\n  var lemma = nounExceptions[noun];\n  if (lemma) return lemma;\n  lemma = noun;\n\n  for (var k = 0; k < nounRegexes.length; k += 1) {\n    lemma = noun.replace(nounRegexes[k].replace, nounRegexes[k].by);\n    if (lemma.length !== noun.length && isNoun(lemma)) return lemma;\n  }\n\n  return noun;\n}; // noun()\n// Create alias to maintain backwards compatibility.\n\n\nlemmatize.lemmatizeNoun = lemmatize.noun;\nlemmatize.lemmatizeVerb = lemmatize.verb;\nlemmatize.lemmatizeAdjective = lemmatize.adjective;\nmodule.exports = lemmatize;","map":{"version":3,"names":["adjectiveExceptions","require","nounExceptions","verbExceptions","words","senseMap","lemmatize","Object","create","isAdjective","word","index","undefined","senses","k","length","adjective","lemma","replace","isVerb","verb","nounRegexes","by","isNoun","noun","lemmatizeNoun","lemmatizeVerb","lemmatizeAdjective","module","exports"],"sources":["D:/Getty-Search-Media-Results/node_modules/wink-lemmatizer/src/wink-lemmatizer.js"],"sourcesContent":["//     wink-lemmatizer\n//     English lemmatizer\n//\n//     This file is part of “wink-lemmatizer”.\n//\n//     Copyright (c) GRAYPE Systems Private Limited\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n// Load adjective/noun/verb exceptions.\nconst adjectiveExceptions = require( 'wink-lexicon/src/wn-adjective-exceptions.js' );\nconst nounExceptions = require( 'wink-lexicon/src/wn-noun-exceptions.js' );\nconst verbExceptions = require( 'wink-lexicon/src/wn-verb-exceptions.js' );\n// Load all words (base form),\nconst words = require( 'wink-lexicon/src/wn-words.js' );\n// and their senses.\nconst senseMap = require( 'wink-lexicon/src/wn-word-senses.js' );\n// The name space.\nconst lemmatize = Object.create( null );\n\n// The following code is an adaptation of [WordNet's Morphy](https://wordnet.princeton.edu/documentation/morphy7wn):\n\n// ### isAdjective\n/**\n * Checks the word in base form is an adjective or not using wordnet senses.\n *\n * @private\n * @method isAdjective\n * @param {string} word that needs to be tested for adjective.\n * @return {boolean} `true` if word is a valid adjective otherwise `false.`\n * @example\n * isAdjective( 'lat' );\n * // -> false\n*/\nvar isAdjective = function ( word ) {\n  const index = words[ word ];\n  if ( index === undefined ) return false;\n  const senses = senseMap[ index ];\n  for ( let k = 0; k < senses.length; k += 1 ) {\n    if ( senses[ k ] < 2 ) return true;\n  }\n  return false;\n}; // isAdjective()\n\n// ### lemmatizeAdjective\n/**\n *\n * Conjugates an `adjective` to it's base form (VB). It also has an alias\n * `lemmatizeAdjective` to maintain API level compatibility with previous version.\n *\n * @method adjective\n * @param {string} adjective that needs to be conjugated to base form.\n * @return {string} the base form of `adjective`.\n * @example\n * lemmatize.adjective( 'farthest' );\n * // -> far\n*/\nlemmatize.adjective = function ( adjective ) {\n  var lemma = adjectiveExceptions[ adjective ];\n  if ( lemma ) return lemma;\n  lemma = adjective.replace( /est$|er$/, '' );\n  if ( lemma.length === adjective.length ) return adjective;\n  if ( isAdjective( lemma ) ) return lemma;\n  lemma += 'e';\n  if ( isAdjective( lemma ) ) return lemma;\n  return adjective;\n}; // adjective()\n\n// ### isVerb\n/**\n * Checks the word in base form is a verb or not using wordnet senses.\n *\n * @private\n * @method isVerb\n * @param {string} word that needs to be tested for verb.\n * @return {boolean} `true` if word is a valid verb otherwise `false.`\n * @example\n * isVerb( 'eat' );\n * // -> true\n*/\nvar isVerb = function ( word ) {\n  const index = words[ word ];\n  if ( index === undefined ) return false;\n  const senses = senseMap[ index ];\n  for ( let k = 0; k < senses.length; k += 1 ) {\n    if ( senses[ k ] > 28 && senses[ k ] < 44  ) return true;\n  }\n  return false;\n}; // isVerb()\n\n// ### lemmatizeVerb\n/**\n *\n * Conjugates a `verb` to it's base form (VB). It also has an alias\n * `lemmatizeVerb` to maintain API level compatibility with previous version.\n *\n * @method verb\n * @param {string} verb that needs to be conjugated to base form.\n * @return {string} the base form of `verb`.\n * @example\n * lemmatize.verb( 'winning' );\n * // -> win\n*/\nlemmatize.verb = function ( verb ) {\n  var lemma = verbExceptions[ verb ];\n  if ( lemma ) return lemma;\n\n  lemma = verb.replace( /s$/, '' );\n  if ( lemma.length !== verb.length && isVerb( lemma ) ) return lemma;\n\n  lemma = verb.replace( /ies$/, 'y' );\n  if ( lemma.length !== verb.length && isVerb( lemma ) ) return lemma;\n\n  lemma = verb.replace( /es$|ed$|ing$/, '' );\n    if ( lemma.length !== verb.length ) {\n    if ( isVerb( lemma ) ) return lemma;\n    lemma += 'e';\n    if ( isVerb( lemma ) ) return lemma;\n  }\n  return verb;\n}; // verb()\n\nconst nounRegexes = [\n  { replace: /s$/, by: '' },\n  { replace: /ses$/, by: 's' },\n  { replace: /xes$/, by: 'x' },\n  { replace: /zes$/, by: 's' },\n  { replace: /ves$/, by: 'f' },\n  { replace: /ches$/, by: 'ch' },\n  { replace: /shes$/, by: 'sh' },\n  { replace: /men$/, by: 'man' },\n  { replace: /ies$/, by: 'y' }\n];\n\n// ### isNoun\n/**\n * Checks the word in base form is a noun or not using wordnet senses.\n *\n * @private\n * @method isNoun\n * @param {string} word that needs to be tested for noun.\n * @return {boolean} `true` if word is a valid noun otherwise `false.`\n * @example\n * isAdjective( 'house' );\n * // -> true\n*/\nvar isNoun = function ( word ) {\n  const index = words[ word ];\n  if ( index === undefined ) return false;\n  const senses = senseMap[ index ];\n  for ( let k = 0; k < senses.length; k += 1 ) {\n    if ( senses[ k ] > 2 && senses[ k ] < 29  ) return true;\n  }\n  return false;\n}; // isNoun()\n\n// ### lemmatizeNoun\n/**\n *\n * Converts the input `noun` to it's singular form. It also has an alias\n * `lemmatizeNoun` to maintain API level compatibility with previous version.\n *\n * @method noun\n * @param {string} noun that needs to be lemmatized.\n * @return {string} the singular of `noun`.\n * @example\n * lemmatize.noun( 'handkerchieves' );\n * // -> handkerchief\n*/\nlemmatize.noun = function ( noun ) {\n  var lemma = nounExceptions[ noun ];\n  if ( lemma ) return lemma;\n\n  lemma = noun;\n  for ( let k = 0; k < nounRegexes.length; k += 1 ) {\n    lemma = noun.replace( nounRegexes[ k ].replace, nounRegexes[ k ].by );\n\n    if ( lemma.length !== noun.length && isNoun( lemma ) ) return lemma;\n  }\n\n  return noun;\n}; // noun()\n\n// Create alias to maintain backwards compatibility.\nlemmatize.lemmatizeNoun = lemmatize.noun;\nlemmatize.lemmatizeVerb = lemmatize.verb;\nlemmatize.lemmatizeAdjective = lemmatize.adjective;\n\nmodule.exports = lemmatize;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}