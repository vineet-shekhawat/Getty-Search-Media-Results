{"ast":null,"code":"//     wink-pos-tagger\n//     English Part-of-speech (POS) tagger\n//\n//     Copyright (C) 2017-19  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-pos-tagger”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n/* eslint-disable no-console */\n//\nvar K = require('./rules/consts.js');\n\nvar posCRsGE0 = require('./rules/pos-rules-ge0.js');\n\nvar valueCRsGE0 = require('./rules/value-rules-ge0.js');\n\nvar posCRsLE0 = require('./rules/pos-rules-le0.js');\n\nvar valueCRsLE0 = require('./rules/value-rules-le0.js'); // ### testValueAtDelta\n\n/**\n *\n * Tests the **value** of token's property defined by `rule.operand.property`\n * using regex `rule.matches` at `rule.operand.delta` away from `cti`.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} rule containing keys `op`, `operand` and `matches` and their\n * corresponding values.\n * @return {boolean} `true` if match occurs otherwise `false`.\n * @private\n*/\n\n\nvar testValueAtDelta = function testValueAtDelta(tokens, cti, rule) {\n  var tAti = tokens[rule.operand.delta + cti];\n  if (tAti && rule.matches.test(tAti[rule.operand.property])) return true;\n  return false;\n}; // testValueAtDelta();\n// ### testValueInRange\n\n/**\n *\n * Tests the **value** of token's property defined by `rule.operand.property`\n * using regex `rule.matches` anywhere within the range specified by array\n * `rule.operand.range`. The array is a 2-element array specifying the range,\n * which is added to `cti` to compute the actual range.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} rule containing keys `op`, `operand` and `matches` and their\n * corresponding values.\n * @return {boolean} `true` if match occurs otherwise `false`.\n * @private\n*/\n\n\nvar testValueInRange = function testValueInRange(tokens, cti, rule) {\n  var tAti;\n\n  for (var i = rule.operand.range[0]; i <= rule.operand.range[1]; i += 1) {\n    tAti = tokens[i + cti];\n    if (tAti && rule.matches.test(tAti[rule.operand.property])) return true;\n  }\n\n  return false;\n}; // testValueInRange()\n\n\nvar operation = Object.create(null);\noperation[K.TEST_VALUE_AT_DELTA] = testValueAtDelta;\noperation[K.TEST_VALUE_IN_RANGE] = testValueInRange; // ### applyContextRule\n\n/**\n *\n * Applies the given `contextRule` on the current token. A rule applicatin may\n * trigger change in the POS at token specified by `thenPosAt` relative distance.\n * The change is applied only if the new POS is amongst one of the valid POSes.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} contextRule contains the specific rule.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {boolean} `true` if pos change occurs otherwise `false`.\n * @private\n*/\n\nvar applyContextRule = function applyContextRule(tokens, cti, contextRule, poses) {\n  var rules = contextRule.rules;\n  var change = true;\n\n  for (var i = 0, imax = rules.length; i < imax && change; i += 1) {\n    change = operation[rules[i].op](tokens, cti, rules[i]);\n  } // Trigger change only if the new `pos` is a valid one — present in `poses`.\n\n\n  if (change && poses[cti].indexOf(contextRule.willBe) !== -1) {\n    tokens[contextRule.thenPosAt + cti].pos = contextRule.willBe;\n    return true;\n  }\n\n  return false;\n}; // applyContextRule()\n// ### applyContextRules\n\n/**\n *\n * Applies given `contextRules` on each token one-by-one. For each token, rules\n * are tried until either a POS change has occurred or all rules have been exhausted\n * without any change.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {object} contextRules contains rules for different POSes. The rules to\n * be applied is selected on the basis of POS of the current token.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {void} Nothing!\n * @private\n*/\n\n\nvar applyContextRules = function applyContextRules(tokens, contextRules, poses) {\n  var rules;\n  var i, imax, j, jmax;\n\n  for (i = 0, imax = tokens.length; i < imax; i += 1) {\n    rules = contextRules[tokens[i].pos];\n\n    if (rules) {\n      for (j = 0, jmax = rules.length; j < jmax && !applyContextRule(tokens, i, rules[j], poses); j += 1) {\n        ;\n      }\n    }\n  }\n}; // applyContextRules()\n// ### applyAllContextRules\n\n/**\n *\n * There are currently 4 sets of context rules. They are first categorized\n * on the basis of `property` of token they use i.e. **value** or **pos**. Each\n * one of them is further categorized on the basis of if the **delta/range** values\n * are **positive** or **negative**. It applies these rules in the required sequence.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {void} Nothing!\n * @private\n*/\n\n\nvar applyAllContextRules = function applyAllContextRules(tokens, poses) {\n  // First apply <0 rules to update POS before looking ahead.\n  // Try `value` specific rules first followed by `pos` specific. In other words\n  // specific rules followed by generic rules.\n  applyContextRules(tokens, valueCRsLE0, poses);\n  applyContextRules(tokens, posCRsLE0, poses); // Already applied <0 rules, time to look ahead.\n\n  applyContextRules(tokens, valueCRsGE0, poses);\n  applyContextRules(tokens, posCRsGE0, poses);\n}; // applyAllContextRules()\n\n\nmodule.exports = applyAllContextRules;","map":{"version":3,"names":["K","require","posCRsGE0","valueCRsGE0","posCRsLE0","valueCRsLE0","testValueAtDelta","tokens","cti","rule","tAti","operand","delta","matches","test","property","testValueInRange","i","range","operation","Object","create","TEST_VALUE_AT_DELTA","TEST_VALUE_IN_RANGE","applyContextRule","contextRule","poses","rules","change","imax","length","op","indexOf","willBe","thenPosAt","pos","applyContextRules","contextRules","j","jmax","applyAllContextRules","module","exports"],"sources":["D:/Getty-Search-Media-Results/node_modules/wink-pos-tagger/src/rules-engine.js"],"sourcesContent":["//     wink-pos-tagger\n//     English Part-of-speech (POS) tagger\n//\n//     Copyright (C) 2017-19  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-pos-tagger”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n/* eslint-disable no-console */\n//\nconst K = require( './rules/consts.js' );\n\nvar posCRsGE0 = require( './rules/pos-rules-ge0.js' );\nvar valueCRsGE0 = require( './rules/value-rules-ge0.js' );\nvar posCRsLE0 = require( './rules/pos-rules-le0.js' );\nvar valueCRsLE0 = require( './rules/value-rules-le0.js' );\n\n// ### testValueAtDelta\n/**\n *\n * Tests the **value** of token's property defined by `rule.operand.property`\n * using regex `rule.matches` at `rule.operand.delta` away from `cti`.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} rule containing keys `op`, `operand` and `matches` and their\n * corresponding values.\n * @return {boolean} `true` if match occurs otherwise `false`.\n * @private\n*/\nvar testValueAtDelta = function ( tokens, cti, rule ) {\n  var tAti = tokens[ rule.operand.delta + cti ];\n  if ( tAti && rule.matches.test( tAti[ rule.operand.property ] ) ) return true;\n  return false;\n}; // testValueAtDelta();\n\n// ### testValueInRange\n/**\n *\n * Tests the **value** of token's property defined by `rule.operand.property`\n * using regex `rule.matches` anywhere within the range specified by array\n * `rule.operand.range`. The array is a 2-element array specifying the range,\n * which is added to `cti` to compute the actual range.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} rule containing keys `op`, `operand` and `matches` and their\n * corresponding values.\n * @return {boolean} `true` if match occurs otherwise `false`.\n * @private\n*/\nvar testValueInRange = function ( tokens, cti, rule ) {\n  var tAti;\n  for ( var i = rule.operand.range[ 0 ]; i <= rule.operand.range[ 1 ]; i += 1 ) {\n    tAti = tokens[ i + cti ];\n    if ( tAti && rule.matches.test( tAti[ rule.operand.property ] ) ) return true;\n  }\n  return false;\n}; // testValueInRange()\n\nvar operation = Object.create( null );\noperation[ K.TEST_VALUE_AT_DELTA ] = testValueAtDelta;\noperation[ K.TEST_VALUE_IN_RANGE ] = testValueInRange;\n\n// ### applyContextRule\n/**\n *\n * Applies the given `contextRule` on the current token. A rule applicatin may\n * trigger change in the POS at token specified by `thenPosAt` relative distance.\n * The change is applied only if the new POS is amongst one of the valid POSes.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {number} cti current token's index.\n * @param {object} contextRule contains the specific rule.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {boolean} `true` if pos change occurs otherwise `false`.\n * @private\n*/\nvar applyContextRule = function ( tokens, cti, contextRule, poses ) {\n  var rules = contextRule.rules;\n  var change = true;\n  for ( var i = 0, imax = rules.length; ( i < imax && change ); i += 1 ) {\n    change = operation[ rules[ i ].op ]( tokens, cti, rules[ i ] );\n  }\n  // Trigger change only if the new `pos` is a valid one — present in `poses`.\n  if ( change && poses[ cti ].indexOf( contextRule.willBe ) !== -1 ) {\n    tokens[ contextRule.thenPosAt + cti ].pos = contextRule.willBe;\n    return true;\n  }\n  return false;\n}; // applyContextRule()\n\n// ### applyContextRules\n/**\n *\n * Applies given `contextRules` on each token one-by-one. For each token, rules\n * are tried until either a POS change has occurred or all rules have been exhausted\n * without any change.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {object} contextRules contains rules for different POSes. The rules to\n * be applied is selected on the basis of POS of the current token.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {void} Nothing!\n * @private\n*/\nvar applyContextRules = function ( tokens, contextRules, poses ) {\n  var rules;\n  var i, imax, j, jmax;\n  for ( i = 0, imax = tokens.length; i < imax; i += 1 ) {\n    rules = contextRules[ tokens[ i ].pos ];\n    if ( rules ) {\n      for ( j = 0, jmax = rules.length; j < jmax && !applyContextRule( tokens, i, rules[ j ], poses ); j += 1);\n    }\n  }\n}; // applyContextRules()\n\n// ### applyAllContextRules\n/**\n *\n * There are currently 4 sets of context rules. They are first categorized\n * on the basis of `property` of token they use i.e. **value** or **pos**. Each\n * one of them is further categorized on the basis of if the **delta/range** values\n * are **positive** or **negative**. It applies these rules in the required sequence.\n *\n * @param {object[]} tokens in wink-tokenizer standards.\n * @param {array[]} poses each element is an array & contains valid POSes for\n * the token at that index in `tokens`.\n * @return {void} Nothing!\n * @private\n*/\nvar applyAllContextRules = function ( tokens, poses ) {\n  // First apply <0 rules to update POS before looking ahead.\n  // Try `value` specific rules first followed by `pos` specific. In other words\n  // specific rules followed by generic rules.\n  applyContextRules( tokens, valueCRsLE0, poses );\n  applyContextRules( tokens, posCRsLE0, poses );\n  // Already applied <0 rules, time to look ahead.\n  applyContextRules( tokens, valueCRsGE0, poses );\n  applyContextRules( tokens, posCRsGE0, poses );\n}; // applyAllContextRules()\n\nmodule.exports = applyAllContextRules;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}