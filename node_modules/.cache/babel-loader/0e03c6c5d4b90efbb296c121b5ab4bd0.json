{"ast":null,"code":"//     wink-pos-tagger\n//     English Part-of-speech (POS) tagger\n//\n//     Copyright (C) 2017-19  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-pos-tagger”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n//\n// Defines the morphological rules for guessing the POS for unknown words.\nvar unknownWordsPOS = require('wink-lexicon/src/unknown-words.js'); // POS for `tag`!\n\n\nvar tagPOS = require('wink-lexicon/src/tags.js');\n\nvar words = require('wink-lexicon/src/wn-words.js');\n\nvar adjExceptions = require('wink-lexicon/src/wn-adjective-exceptions.js');\n\nvar nounExceptions = require('wink-lexicon/src/wn-noun-exceptions.js');\n\nvar verbExceptions = require('wink-lexicon/src/wn-verb-exceptions.js');\n\nvar senseMap = require('wink-lexicon/src/wn-word-senses.js'); // POS for punctuations.\n\n\nvar punctuationPOS = require('wink-lexicon/src/punctuations.js');\n\nvar rgxs4POS = [// 0-2: NNS/VBZ\n{\n  replace: /s$/,\n  by: ''\n}, {\n  replace: /es$/,\n  by: ''\n}, {\n  replace: /ies$/,\n  by: 'y'\n}, // 3-4: VBG\n{\n  replace: /ing$/,\n  by: ''\n}, {\n  replace: /ing$/,\n  by: 'e'\n}, // 5-6: VBD/VBN\n{\n  replace: /ed$/,\n  by: ''\n}, {\n  replace: /d$/,\n  by: ''\n}, // 7-8: JJR\n{\n  replace: /er$/,\n  by: ''\n}, {\n  replace: /r$/,\n  by: ''\n}, // 9-10: JJS\n{\n  replace: /est$/,\n  by: ''\n}, {\n  replace: /st$/,\n  by: ''\n}, // Balance: NNS\n{\n  replace: /xes$/,\n  by: 'x'\n}, {\n  replace: /zes$/,\n  by: 's'\n}, {\n  replace: /ves$/,\n  by: 'f'\n}, {\n  replace: /ches$/,\n  by: 'ch'\n}, {\n  replace: /shes$/,\n  by: 'sh'\n}, {\n  replace: /men$/,\n  by: 'man'\n}]; // ### isPotentialWord\n\n/**\n *\n * Checks if the supplied `word` is potentially a valid English word by\n * applying regexes sequentially and performaling a level-2 look up.\n *\n * @param {string} word that needs to be checked\n * @return {boolean} true if it is a potential English word, otherwise false.\n * @private\n*/\n\nvar isPotentialWord = function isPotentialWord(word) {\n  for (var i = 0, imax = rgxs4POS.length; i < imax; i += 1) {\n    if (rgxs4POS[i].replace.test(word)) {\n      if (words[word.replace(rgxs4POS[i].replace, rgxs4POS[i].by)] !== undefined) return true;\n    }\n  }\n\n  return false;\n}; // ### unigramL2POSTagger\n\n/**\n *\n * Tags a single input `token` whose lookup has failed in the `lexicon`. Attempts\n * to apply morphological rules if token is found in the level-2 lookup.\n * Finally falls bact to NNP!\n *\n * @param {object} token that needs to be tagged; must follow wink-tokenizer.\n * standards.\n * @param {object} lexicon containing word/pos key/value pairs.\n * @return {array} the array of all possible part-of-speeches.\n * @private\n*/\n\n\nvar unigramL2POSTagger = function unigramL2POSTagger(token, lexicon) {\n  var word = token.normal;\n  var index = words[word];\n  var pos;\n\n  if (index || adjExceptions[word] || nounExceptions[word] || verbExceptions[word] || isPotentialWord(word)) {\n    if (index && senseMap[index][0] === 15 && /^[A-Z][a-z]+/.test(token.value)) {\n      pos = 'NNP';\n    } else {\n      // Word exists, can apply morphological rules safely.\n      // Their sequence of application is important: match the longest\n      // one first!\n      pos = unknownWordsPOS[word.slice(-4)] || unknownWordsPOS[word.slice(-3)] || unknownWordsPOS[word.slice(-2)] || unknownWordsPOS[word.slice(-1)];\n\n      if (!pos && word.slice(0, 2) === 'un' && lexicon[word.slice(2)]) {\n        pos = 'JJ';\n      }\n    }\n  } else {\n    // Seems like an unknown word, make it proper noun!\n    pos = 'NNP';\n  } // Return poses intelligently to allow the context rules to work!\n\n\n  return pos === undefined ? ['NN', 'VBP', 'VB'] : pos === 'NNS' ? ['NNS', 'VBZ'] : pos === 'VBN' ? ['VBD', 'VBN'] : [pos];\n}; // unigramL2POSTagger()\n// ### unigramPOSTagger\n\n/**\n *\n * Tags a single input `token` using the `lexicon`. Attempts to apply\n * morphological rules if the primary look up fails but secondary one succeeds.\n * Finally falls bact to NNP!\n *\n * @param {object} token that needs to be tagged; must follow wink-tokenizer.\n * standards.\n * @param {object} lexicon containing word/pos key/value pairs.\n * @return {array} the array of all possible part-of-speeches.\n * @private\n*/\n\n\nvar unigramPOSTagger = function unigramPOSTagger(token, lexicon) {\n  // If token is an **entity with pos defined**, no tagging is needed.\n  if (token.entityType && token.pos) return [token.pos]; // Use `normalize()` to obtain the word and not `toLowerCase()`.\n\n  var word = token.normal; // Arrray of pos for the word from lexicon.\n\n  var poses; // Finish off with punctuations first.\n\n  if (token.tag === 'punctuation') {\n    // `|| token.value` is a catch all clause! In other words, unknown\n    // punctuation will have a pos as **it's value**.\n    token.pos = punctuationPOS[token.value] || token.value;\n    return [token.pos];\n  }\n\n  if (token.tag === 'symbol' && token.value !== '&') {\n    token.pos = 'NN';\n    return [token.pos];\n  } // Start with tag lookup!\n\n\n  token.pos = tagPOS[token.tag];\n\n  if (token.pos === undefined) {\n    // Didn't work, try dictionary lookup.\n    poses = lexicon[word] || unigramL2POSTagger(token, lexicon);\n    token.pos = poses[0];\n  } else {\n    // Tag POS is returned.\n    return [token.pos];\n  } // The `poses` can be undefined in case of unknown words, un-adjectives & NN fallback.\n\n\n  return poses;\n}; // unigramPOSTagger();\n\n\nmodule.exports = unigramPOSTagger;","map":{"version":3,"names":["unknownWordsPOS","require","tagPOS","words","adjExceptions","nounExceptions","verbExceptions","senseMap","punctuationPOS","rgxs4POS","replace","by","isPotentialWord","word","i","imax","length","test","undefined","unigramL2POSTagger","token","lexicon","normal","index","pos","value","slice","unigramPOSTagger","entityType","poses","tag","module","exports"],"sources":["D:/Getty-Search-Media-Results/node_modules/wink-pos-tagger/src/unigram-tagger.js"],"sourcesContent":["//     wink-pos-tagger\n//     English Part-of-speech (POS) tagger\n//\n//     Copyright (C) 2017-19  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-pos-tagger”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\n// Defines the morphological rules for guessing the POS for unknown words.\nvar unknownWordsPOS = require( 'wink-lexicon/src/unknown-words.js' );\n\n// POS for `tag`!\nvar tagPOS = require( 'wink-lexicon/src/tags.js' );\nvar words = require( 'wink-lexicon/src/wn-words.js' );\nvar adjExceptions = require( 'wink-lexicon/src/wn-adjective-exceptions.js' );\nvar nounExceptions = require( 'wink-lexicon/src/wn-noun-exceptions.js' );\nvar verbExceptions = require( 'wink-lexicon/src/wn-verb-exceptions.js' );\nvar senseMap = require( 'wink-lexicon/src/wn-word-senses.js' );\n\n// POS for punctuations.\nvar punctuationPOS = require( 'wink-lexicon/src/punctuations.js' );\n\nconst rgxs4POS = [\n  // 0-2: NNS/VBZ\n  { replace: /s$/, by: '' },\n  { replace: /es$/, by: '' },\n  { replace: /ies$/, by: 'y' },\n  // 3-4: VBG\n  { replace: /ing$/, by: '' },\n  { replace: /ing$/, by: 'e' },\n  // 5-6: VBD/VBN\n  { replace: /ed$/, by: '' },\n  { replace: /d$/, by: '' },\n  // 7-8: JJR\n  { replace: /er$/, by: '' },\n  { replace: /r$/, by: '' },\n  // 9-10: JJS\n  { replace: /est$/, by: '' },\n  { replace: /st$/, by: '' },\n  // Balance: NNS\n  { replace: /xes$/, by: 'x' },\n  { replace: /zes$/, by: 's' },\n  { replace: /ves$/, by: 'f' },\n  { replace: /ches$/, by: 'ch' },\n  { replace: /shes$/, by: 'sh' },\n  { replace: /men$/, by: 'man' }\n];\n\n// ### isPotentialWord\n/**\n *\n * Checks if the supplied `word` is potentially a valid English word by\n * applying regexes sequentially and performaling a level-2 look up.\n *\n * @param {string} word that needs to be checked\n * @return {boolean} true if it is a potential English word, otherwise false.\n * @private\n*/\nvar isPotentialWord = function ( word ) {\n  for ( var i = 0, imax = rgxs4POS.length; i < imax; i += 1 ) {\n    if ( rgxs4POS[ i ].replace.test( word ) ) {\n      if ( words[ word.replace( rgxs4POS[ i ].replace, rgxs4POS[ i ].by ) ] !== undefined ) return true;\n    }\n  }\n\n  return false;\n};\n\n// ### unigramL2POSTagger\n/**\n *\n * Tags a single input `token` whose lookup has failed in the `lexicon`. Attempts\n * to apply morphological rules if token is found in the level-2 lookup.\n * Finally falls bact to NNP!\n *\n * @param {object} token that needs to be tagged; must follow wink-tokenizer.\n * standards.\n * @param {object} lexicon containing word/pos key/value pairs.\n * @return {array} the array of all possible part-of-speeches.\n * @private\n*/\nvar unigramL2POSTagger = function ( token, lexicon ) {\n  var word = token.normal;\n  var index = words[ word ];\n  var pos;\n  if ( index || adjExceptions[ word ] || nounExceptions[ word] || verbExceptions[ word ] || isPotentialWord( word ) ) {\n    if ( index && senseMap[ index ][ 0 ] === 15 && ( /^[A-Z][a-z]+/ ).test( token.value ) ) {\n      pos = 'NNP';\n    } else {\n      // Word exists, can apply morphological rules safely.\n      // Their sequence of application is important: match the longest\n      // one first!\n      pos = ( unknownWordsPOS[ word.slice( -4 ) ] ||\n              ( unknownWordsPOS[ word.slice( -3 ) ] ||\n                ( unknownWordsPOS[ word.slice( -2 ) ] ||\n                    unknownWordsPOS[ word.slice( -1 ) ] ) ) );\n      if ( !pos && word.slice( 0, 2 ) === 'un' && lexicon[ word.slice( 2 ) ] ) {\n        pos = 'JJ';\n      }\n    }\n  } else {\n    // Seems like an unknown word, make it proper noun!\n    pos = 'NNP';\n  }\n  // Return poses intelligently to allow the context rules to work!\n  return ( ( pos === undefined ) ?\n            [ 'NN', 'VBP', 'VB' ] : ( pos === 'NNS' ) ?\n              [ 'NNS', 'VBZ' ] : ( pos === 'VBN' ) ?\n                  [ 'VBD', 'VBN' ] : [ pos ]\n         );\n}; // unigramL2POSTagger()\n\n// ### unigramPOSTagger\n/**\n *\n * Tags a single input `token` using the `lexicon`. Attempts to apply\n * morphological rules if the primary look up fails but secondary one succeeds.\n * Finally falls bact to NNP!\n *\n * @param {object} token that needs to be tagged; must follow wink-tokenizer.\n * standards.\n * @param {object} lexicon containing word/pos key/value pairs.\n * @return {array} the array of all possible part-of-speeches.\n * @private\n*/\nvar unigramPOSTagger = function ( token, lexicon ) {\n  // If token is an **entity with pos defined**, no tagging is needed.\n  if ( token.entityType && token.pos ) return [ token.pos ];\n  // Use `normalize()` to obtain the word and not `toLowerCase()`.\n  var word = token.normal;\n  // Arrray of pos for the word from lexicon.\n  var poses;\n  // Finish off with punctuations first.\n  if ( token.tag === 'punctuation' ) {\n    // `|| token.value` is a catch all clause! In other words, unknown\n    // punctuation will have a pos as **it's value**.\n    token.pos = punctuationPOS[ token.value ] || token.value;\n    return [ token.pos ];\n  }\n  if ( token.tag === 'symbol' && token.value !== '&' ) {\n    token.pos = 'NN';\n    return [ token.pos ];\n  }\n  // Start with tag lookup!\n  token.pos = tagPOS[ token.tag ];\n  if ( token.pos === undefined ) {\n    // Didn't work, try dictionary lookup.\n    poses = lexicon[ word ] || unigramL2POSTagger( token, lexicon );\n    token.pos = poses[ 0 ];\n  } else {\n    // Tag POS is returned.\n    return [ token.pos ];\n  }\n  // The `poses` can be undefined in case of unknown words, un-adjectives & NN fallback.\n  return ( poses );\n}; // unigramPOSTagger();\n\nmodule.exports = unigramPOSTagger;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}